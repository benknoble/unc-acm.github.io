<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title></title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html --> 
<meta name="src" content="lesson.tex"> 
<meta name="date" content="2017-02-01 10:34:00"> 
<link rel="stylesheet" type="text/css" href="lesson.css"> 
<style type="text/css">
body {
    margin:40px auto;
    max-width:650px;
    line-height:1.6;
    font-size:18px;
    color:#444;
    padding:0 10px
}

h1,h2,h3 {
    line-height:1.2
}
</style>
</head><body 
>
<h3 class="likesectionHead"><a 
 id="x1-1000"></a>Introducation to Graph Theory</h3>
<!--l. 60--><p class="noindent" >
<h4 class="likesubsectionHead"><a 
 id="x1-2000"></a>Definition and Representation</h4>
<!--l. 62--><p class="noindent" >In mathematical and computer science terms, a graph is a collection of values (known as nodes or
vertices) and a collection of connections, known as edges. This is frequently represented by
endpoints and line segments connecting them. Mathematically a graph is a tuple of two sets,
<span 
class="cmmi-12">G</span>(<span 
class="cmmi-12">E,V </span>), an edge set and a vertex set. Graph functions as a template to abstract many problems,
it represents relationships between similar constructs.
<!--l. 69--><p class="noindent" >For the purposes of complexity analysis, the runtime is often expressed in terms of the size of the
<span 
class="cmmi-12">E </span>and <span 
class="cmmi-12">V </span>sets, similar to how complexities of operations with 1D data structures is often in
terms of the length. In most cases, we can make the assumption of <span 
class="cmmi-12">E </span><span 
class="cmsy-10x-x-120">&asymp; </span><span 
class="cmmi-12">V</span> <sup><span 
class="cmr-8">2</span></sup>. This is
because in a fully connected graph, the size of the edge set is equal to <span 
class="cmmi-12">V </span>(<span 
class="cmmi-12">V </span><span 
class="cmsy-10x-x-120">&minus; </span>1), and in
contests it is often best to assume the worst unless there&#8217;s a good reason for acting
otherwise.
<!--l. 77--><p class="noindent" >There are many types of graphs, and each of them are used to represent different relationships
between values, and their difference is mostly on what the edges can be. To start off there&#8217;s
directed and undirected graphs, in directed graphs the edges only go in one direction whereas in
undirected graphs the edges go in both. There are further restrictions on whether the edge length
is specified, as well as the allowed range of the length, for example, some graphs call for
negative edge lengths while others restrict the edge lengths to only positive. For the
purposes of this lecture, we are going to deal with directed graphs with positive edge
lengths.
<!--l. 87--><p class="noindent" >I know that we usually don&#8217;t go into implementation in this class. But the implementation of a
graph can also help us visualize information. There are two major ways of representing
graph:
      <ul class="itemize1">
      <li class="itemize">Adjacency Matrix: A 2D array of booleans (or edge lengths) where the indices are the
      nodes connecting the edge.
      </li>
      <li class="itemize">Edge List: This involves a slight modification of the node data structure, which is
      usually just a 1D array, but this modification involves adding an additional list of
      connected vertices.</li></ul>
                                                                                         
                                                                                         
<!--l. 98--><p class="noindent" >The advantage of using adjacency matrix is that it&#8217;s much simpler to code up, the disadvantage is
that it uses a lot of space. But I digress, back to graph algorithms.
<!--l. 102--><p class="noindent" >
<h4 class="likesubsectionHead"><a 
 id="x1-3000"></a>Depth First Search and Applications</h4>
<!--l. 104--><p class="noindent" >The most basic algorithm we will study today is the depth first search, otherwise known as depth
first transversal. The point of this algorithm is to find a path from one node to another. Let&#8217;s look
through an example together.
<!--l. 108--><p class="noindent" >We are going to solve a maze. A maze can be represented as a graph where each grid point
represent a vertex and if two points are &#8220;adjacent,&#8221; i.e. If you can reach one square from another,
then they are connected by an edge in our representation.
<!--l. 113--><p class="noindent" >The algorithm goes as follows, we keep a list of booleans corresponding to the list of vertices.
This list marks if a square has been visited or not. We start by the beginning of the
maze.
<!--l. 117--><p class="noindent" >At each crossroads (aka each vertex with more than one edge coming out of it). We will recursively
search along each of the paths until it reaches either an exit, in which case we&#8217;re done, or a dead
end, or a visited node. In either of the later cases we go one the next branch, hence earning the
algorithm its name <span 
class="cmbx-12">depth first search (DFS)</span>, because it always going the full depth along each
path.
<!--l. 124--><p class="noindent" >This algorithm has the complexity of <span 
class="cmmi-12">O</span>(<span 
class="cmmi-12">E </span>+ <span 
class="cmmi-12">V </span>), as in the worst case we are guaranteed to visit
every vertex, and in doing so we have to traverse every edge. Using the earlier substitution, the
worse case scenario can be estimated to be about <span 
class="cmmi-12">O</span>(<span 
class="cmmi-12">V</span> <sup><span 
class="cmr-8">2</span></sup>).
                                                                                         
                                                                                         
<div class="verbatim" id="verbatim-1">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;+#
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#################
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;#
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;##################
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;#######&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;##########&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;###&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;####################&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#####&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;################&#x00A0;&#x00A0;&#x00A0;###############
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#######
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;##########$</div>
<!--l. 145--><p class="nopar" >
<!--l. 147--><p class="noindent" >This algorithm is actually very versatile and has profound implications, for example, it can be used
to detect if a graph is connected or have several disconnected pieces. This can be done by trying
to traverse the graph with no endpoint, only seeking to mark all nodes as visited. If
the call returns and there still exists unvisited nodes, those nodes are disconnected
from the starting point, allowing us to subdivide an unconnected graph into connected
pieces.
<!--l. 155--><p class="noindent" >Another modification of this algorithm is cycle detection. Recall the few terminating conditions,
another one we haven&#8217;t used yet is reaching a previously visited node. Think about what this
means. If we hit a previously visited node, that means there is a cycle in our graph starting at that
node. This will also come in handy in problems.
<!--l. 161--><p class="noindent" >
<h4 class="likesubsectionHead"><a 
 id="x1-4000"></a>Breath First Search and Meet In The Middle</h4>
<!--l. 163--><p class="noindent" >An alternative method of transversal is known as breath first search or transversal. As its name
suggests, unlike depth first search this method takes one step in all possible directions. This is a
different algorithm but the basic tenement is the same. As a transversal algorithm, it can do
everything depth first search can, including connectedness and cycle detection. This approach has
two advantages. The first being that if we are looking for a path between two nodes, breath first
search guarantees an optimal solution. The second is that it has a much better average time
complexity than depth first search. Consider we are trying to get from point A to point B, but A
                                                                                         
                                                                                         
branches into B and C, and in DFS, if we stumble into C, we will reach the worst case
before we get to B, but with breath first search we are guaranteed to reach B in one
step.
<!--l. 175--><p class="noindent" >In breath first search, if the average degree of the graph is <span 
class="cmmi-12">p </span>and the true distance between the
starting and ending positions is <span 
class="cmmi-12">d</span>, then <span 
class="cmmi-12">O</span>(<span 
class="cmmi-12">p</span><sup><span 
class="cmmi-8">d</span></sup>) nodes will be traversed, whereas DFS
is much more erratic and &#8220;luck based.&#8221; However, the choice of which to use is highly
context dependent. While BFS offers the potential for higher speed, it uses up a lot
of memory, making it potentially unfeasible. It may also be the case that there are
many desirable results and they are all far in the graph, in which case DFS will be
preferable.
<!--l. 183--><p class="noindent" >
<h5 class="likesubsubsectionHead"><a 
 id="x1-5000"></a>Meet in the Middle</h5>
<!--l. 185--><p class="noindent" >Let&#8217;s talk about an interview question. Given the name of two people on Facebook, how does one
find their degrees of separation.
<!--l. 188--><p class="noindent" >This is one of those cases where DFS would not solve the problem for rather obvious reasons. But
let&#8217;s talk about BFS, starting from friend A, if we were to find the distance to friend B via BFS,
we will have to traverse <span 
class="cmmi-12">O</span>(<span 
class="cmmi-12">p</span><sup><span 
class="cmmi-8">d</span></sup>) people as previously stated.
<!--l. 193--><p class="noindent" >Sociology theory says that <span 
class="cmmi-12">d </span>is bounded by 6, and let&#8217;s put a lower bound on <span 
class="cmmi-12">p </span>as, say, 150. This
means that we will need to traverse about 150<sup><span 
class="cmr-8">6</span></sup> = 11390625000000 people. This is not good
enough.
<!--l. 197--><p class="noindent" >Consider, however, that we concurrently conduct BFS from both A and B. Each with their own
unique visited-A and visited-B markings. Then if they encounter the visited marking
of the other person, we are done. This effectively reduced the complexity of <span 
class="cmmi-12">O</span>(<span 
class="cmmi-12">p</span><sup><span 
class="cmmi-8">d</span></sup>) to
<span 
class="cmmi-12">O</span>(2 <span 
class="cmsy-10x-x-120">&#x00D7; </span><span 
class="cmmi-12">p</span><sup><span 
class="cmmi-8">d&#x2215;</span><span 
class="cmr-8">2</span></sup>), which further reduces to <span 
class="cmmi-12">O</span>(<span 
class="cmmi-12">p</span><sup><span 
class="cmmi-8">d&#x2215;</span><span 
class="cmr-8">2</span></sup>), a drastic decrease. In our example it
reduces the number of people traversed to 2 <span 
class="cmsy-10x-x-120">&lowast; </span>150<sup><span 
class="cmr-8">3</span></sup> = 6750000, which is much, much
less.
<!--l. 204--><p class="noindent" >Although we introduced this technique in the context of graph theory, this technique
can be used in a variety of settings. However, this technique is usually known as the
&#8220;smart brute-force&#8221; method, and you should only try to do it when there is no other
algorithms.
<!--l. 209--><p class="noindent" >Let&#8217;s see an example outside the context of graphs, and yet another popular interview question,
the four number problem!
<!--l. 212--><p class="noindent" >The problem is as follows, you are given a list of integers with length <span 
class="cmmi-12">n</span>, find if there exists 4
number <span 
class="cmmi-12">a,b,c,d </span>s.t. <span 
class="cmmi-12">a </span>+ <span 
class="cmmi-12">b </span>+ <span 
class="cmmi-12">c </span>+ <span 
class="cmmi-12">d </span>= 0.
<!--l. 215--><p class="noindent" >The brute force solution is to try all combination of 4 numbers, which is <span 
class="cmmi-12">O</span>(<span 
class="cmmi-12">n</span><sup><span 
class="cmr-8">4</span></sup>). For those interview
oldies, you probably know that &#8220;a hashtable makes everything better,&#8221; so a slightly
                                                                                         
                                                                                         
better solution is to hash all possible <span 
class="cmsy-10x-x-120">&minus;</span>(<span 
class="cmmi-12">a </span>+ <span 
class="cmmi-12">b </span>+ <span 
class="cmmi-12">c</span>) and check that against the original
array.
<!--l. 220--><p class="noindent" >That last approach is incredibly close to the correct one, but as the name suggests, meet in
the <span 
class="cmbx-12">middle </span>requires using symmetry to our maximum advantage. The insight is that
<span 
class="cmsy-10x-x-120">&minus;</span>(<span 
class="cmmi-12">a </span>+ <span 
class="cmmi-12">b</span>) = (<span 
class="cmmi-12">c </span>+ <span 
class="cmmi-12">d</span>). We still use a hashset, and store all possible <span 
class="cmsy-10x-x-120">&minus;</span>(<span 
class="cmmi-12">a </span>+ <span 
class="cmmi-12">b</span>)&#8217;s, then we iterate through
all possible (<span 
class="cmmi-12">c </span>+ <span 
class="cmmi-12">d</span>)&#8217;s and check them against the subset. This has complexity of <span 
class="cmmi-12">O</span>(<span 
class="cmmi-12">n</span><sup><span 
class="cmr-8">2</span></sup>), which is
better than either of the previous ones.  
</body></html> 

                                                                                         


